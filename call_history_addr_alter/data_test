import os
import sys
import gc
import re
import smtplib
from pandas import Series, DataFrame
from email.mime.text import MIMEText
from email.header import Header
import pandas as pd
import time
import datetime
import threading
import webbrowser
from collections import  Iterator
import copy
from urllib import parse
import urllib.request
import operator
from collections import Counter
import logging
import itertools
import matplotlib.pyplot as plt
import numpy as np
import datetime
import dateutil.parser as dp
import pytz
import tkinter
import scrapy
from bs4 import BeautifulSoup
import math
import json
import requests
import pymysql
from dateutil.parser import parse
from functools import reduce
from pyspark.sql.types import *
from sklearn import linear_model
def mysql_connection(select_string):
    start = time.time()
    conn = pymysql.connect(host='rr-bp1jnr76z49y5k9mno.mysql.rds.aliyuncs.com', port=3306, user='qiandaodao',
                           passwd='qdddba@2017*', db='qiandaodao', charset='utf8',  cursorclass=pymysql.cursors.DictCursor)
    print('已经连接到数据库，请稍候...')
    cur = conn.cursor()
    cur.execute(select_string)
    data = DataFrame(cur.fetchall())
    # print(data)
    print('已经查询到数据，正在处理，请稍候...查询花费时间为%ds。' % (time.time() - start))
    # 提交
    conn.commit()
    # 关闭指针对象
    cur.close()
    # 关闭连接对象
    conn.close()
    return data


#通讯录
def address_test(mobile):
    select_string = '''
    SELECT users.id as user_id, users.mobile, users.create_time,  ab.device, ab.name, ab.mobile as book_mobile FROM qiandaodao.address_book as ab inner join users on ab.device = users.device
where users.mobile = '{mobile}'
    '''.format(mobile=mobile)
    data = mysql_connection(select_string)
    # print('++++++++++++++++++', data)
    return data


#通话记录
def call_test(path_item):
    path = 'C:\\Users\\QDD\\Desktop\\operator\\operator\\'
    item_list = []
    with open(path+path_item, encoding='utf-8') as f1:
        data = json.load(f1)
    for num in data['calls']:
        data_new = pd.DataFrame(num['items'])
        item_list.append(data_new)
    data = pd.concat(item_list, ignore_index=True)
    data['mobile'] = path_item[0:11]
    print(path_item[0:11])
    create_time = address_test(path_item[0:11]).ix[0, 'create_time']
    print(create_time, type(create_time))
    if len(str(create_time)) != 0:
        data['create_time'] = str(create_time)
    else:
        print('create_time为空')
    # data.to_csv('C:\\Users\\QDD\\Desktop\\' + path_item[0:11] + '.csv', sep=',', encoding='gbk', index=False)
    return data


#得到近7天， 30天， 90天的通话记录
def time_call_data(data):
    #当天不算，从0点开始算， 这是北京时间，而系统是按utc时间处理的
    create_time = str(data.ix[0,'create_time'])[:-8] + '00:00:00'
    print(create_time)
    print('_______________________')
    time_tuple = time.strptime(create_time, '%Y-%m-%d %H:%M:%S')
    print(time_tuple)
    time_stamp = time.mktime(time_tuple)
    print(time_stamp)

    latest_7 = time_stamp + 8*3600 - 1*24*3600
    latest_7_time = time.strftime('%Y-%m-%d %H:%M:%S',  time.gmtime(latest_7))
    print(time.gmtime(latest_7))
    print('**************', latest_7_time)
    data_1 = data[(data['time'] > latest_7_time) & (data['time'] < create_time)]

    latest_30 = time_stamp + 8*3600 - 30*24*3600
    latest_30_time = time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(latest_30))
    data_2 = data[(data['time'] > latest_30_time) & (data['time'] < create_time)]

    latest_90 = time_stamp + 8*3600 - 90*24*3600
    latest_90_time = time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(latest_90))
    data_3 = data[(data['time'] > latest_90_time) & (data['time'] < create_time)]

    return [[data_1, 7], [data_2, 30], [data_3, 90]]


def time_analysis(data):
        # 当天不算，从0点开始算， 这是北京时间，而系统是按utc时间处理的
        create_time = str(data.ix[0, 'create_time'])[:-8] + '00:00:00'
        print('_______________________')
        time_tuple = time.strptime(create_time, '%Y-%m-%d %H:%M:%S')
        time_stamp = time.mktime(time_tuple)

        latest_7 = time_stamp + 8 * 3600 - 1 * 24 * 3600
        latest_7_time = time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(latest_7))

        latest_30 = time_stamp + 8 * 3600 - 30 * 24 * 3600
        latest_30_time = time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(latest_30))

        latest_90 = time_stamp + 8 * 3600 - 90 * 24 * 3600
        latest_90_time = time.strftime('%Y-%m-%d %H:%M:%S', time.gmtime(latest_90))

        return [[latest_7_time, create_time], [latest_30_time, create_time], [latest_90_time, create_time]]



#夜间通话次数
def night_call_times(data):
    #找到通话时间在1：00和4：00的通话记录
    data = data[(data['time'].str[-8:]<'04:00:00') & (data['time'].str[-8:]>'01:00:00')]
    print('\n夜间通话次数：', data)
    times = len(data)
    return times


#有效手机号，主叫，被叫的数量
def call_valid_num(data):
    print(data.dtypes)
    data['peer_number'] = data['peer_number'].astype('str')
    data_valid = data[data['peer_number'].str.match('1[3-9]\d{9}')]
    data_DIAL = data_valid[data_valid['dial_type']=='DIAL']
    data_DIALED = data_valid[data_valid['dial_type']=='DIALED']
    #去重后的手机号数量一般小于主叫和被叫的号码数量之和，存在重复计算的情况
    data_valid_drop = data_valid.drop_duplicates('peer_number')
    data_DIAL_drop = data_DIAL.drop_duplicates('peer_number')
    data_DIALED_drop = data_DIALED.drop_duplicates('peer_number')

    return [len(data_valid_drop), len(data_DIAL_drop), len(data_DIALED_drop)]


#7天、30天、90天的通话记录中，连续一天、两天、三天未通话的次数
def continue_no_call_times(data_list, time_range_list):
    #要把每种情况都要考虑到，否则程序就报错
    #data_list的数据包括data和对应的天数（7，30，90）， time_range_list为不同通话记录的起始时间
    data = data_list[0]
    days = data_list[1]
    if len(data) == 0:
        return [0, 0, 0]
    else:
        #转换成日期（去掉时间），注意从2018-01-07 00:00:00到2018-01-08 00:00:00只有一天，如果只看日期，去掉时间，就是两天，计算时再去掉一天
        date_index_7 = pd.date_range(time_range_list[0][0][:-8], time_range_list[0][1][:-8], freq='D')
        date_index_30 = pd.date_range(time_range_list[1][0][:-8], time_range_list[1][1][:-8], freq='D')
        date_index_90 = pd.date_range(time_range_list[2][0][:-8], time_range_list[2][1][:-8], freq='D')

        data['date'] = data['time'].str[:10]
        data_drop = data.drop_duplicates('date')
        # print(data_drop)
        data = data_drop.set_index('date', drop=False)
        data.index = pd.to_datetime(data.index)

        #定义一个函数，计算不同天数通话记录的处理结果
        def inner_analysis(date_index):
            data_days = data.reindex(date_index)
            data_days = data_days.fillna('null')
            # 之前去掉时间，只看日期时，多算了一天，这里要去掉一天，index_null_days即为没有通话的日期
            index_null_days = data_days[data_days['time'] == 'null'].index[:-1]
            # 分别为连续一天，两天，三天无通话的次数
            count_days_1 = len(index_null_days)
            count_days_2 = 0
            count_days_3 = 0
            for key, item in enumerate(index_null_days):
                if key > 0:
                    if (index_null_days[key] - index_null_days[key - 1]).days == 1:
                        count_days_2 += 1
                        print(count_days_2)
                if key > 1:
                    if ((index_null_days[key] - index_null_days[key - 1]).days == 1) and (
                                (index_null_days[key - 1] - index_null_days[key - 2]).days == 1):
                        count_days_3 += 1
            result_list = [count_days_1, count_days_2, count_days_3]
            return result_list

        if days ==7:
            result_list = inner_analysis(date_index_7)
            # data_7 = data.reindex(date_index_7)
            # data_7 = data_7.fillna('null')
            # # 之前去掉时间，只看日期时，多算了一天，这里要去掉一天，index_null_7即为没有通话的日期
            # index_null_7 = data_7[data_7['time'] == 'null'].index[:-1]
            # # 分别为连续一天，两天，三天无通话的次数
            # count_7_1 = len(index_null_7)
            # count_7_2 = 0
            # count_7_3 = 0
            # for key, item in enumerate(index_null_7):
            #     if key > 0:
            #         if (index_null_7[key] - index_null_7[key - 1]).days == 1:
            #             count_7_2 += 1
            #             print(count_7_2)
            #     if key > 1:
            #         if ((index_null_7[key] - index_null_7[key - 1]).days == 1) and (
            #                     (index_null_7[key - 1] - index_null_7[key - 2]).days == 1):
            #             count_7_3 += 1
            # result_list= [count_7_1, count_7_2, count_7_3]
        elif days == 30:
            result_list = inner_analysis(date_index_30)
            # data_30 = data.reindex(date_index_30)
            # data_30 = data_30.fillna('null')
            # # 之前去掉时间，只看日期时，多算了一天，这里要去掉一天，index_null_30即为没有通话的日期
            # index_null_30 = data_30[data_30['time'] == 'null'].index[:-1]
            # # 分别为连续一天，两天，三天无通话的次数
            # count_30_1 = len(index_null_30)
            # count_30_2 = 0
            # count_30_3 = 0
            # for key, item in enumerate(index_null_30):
            #     if key > 0:
            #         if (index_null_30[key] - index_null_30[key - 1]).days == 1:
            #             count_30_2 += 1
            #             print(count_30_2)
            #     if key > 1:
            #         if ((index_null_30[key] - index_null_30[key - 1]).days == 1) and (
            #             (index_null_30[key - 1] - index_null_30[key - 2]).days == 1):
            #             count_30_3 += 1
            # result_list = [count_30_1, count_30_2, count_30_3]
        elif days == 90:
            result_list = inner_analysis(date_index_90)
            # data_90 = data.reindex(date_index_90)
            # data_90 = data_90.fillna('null')
            # #之前去掉时间，只看日期时，多算了一天，这里要去掉一天，index_null_90即为没有通话的日期
            # index_null_90 = data_90[data_90['time']=='null'].index[:-1]
            # #分别为连续一天，两天，三天无通话的次数
            # count_90_1 = len(index_null_90)
            # count_90_2 = 0
            # count_90_3 = 0
            # for key, item in enumerate(index_null_90):
            #     if key>0:
            #         if (index_null_90[key] - index_null_90[key-1]).days == 1:
            #             count_90_2 += 1
            #             print(count_90_2)
            #     if key > 1:
            #         if ((index_null_90[key] - index_null_90[key-1]).days == 1) and ((index_null_90[key-1] - index_null_90[key-2]).days == 1):
            #             count_90_3 += 1
            # result_list = [count_90_1, count_90_2, count_90_3]
            # print("90天:", index_null_90)
        else:
            print('通话记录天数不在7，30， 90的范围内')
        return result_list


if __name__ == '__main__':
    path = 'C:\\Users\\QDD\\Desktop\\operator\\operator\\'
    file_list = os.listdir(path)
    #样本的号码
    mobile_list = []
    for item in file_list:
        mobile = item[0:11]
        mobile_list.append(mobile)
        call_data = call_test(item)
        address_data = address_test(mobile)
        #得到近7天， 30天， 90天的通话记录
        call_data_list = time_call_data(call_data)
        #得到近7天， 30天， 90天的起止时间
        time_range_list = time_analysis(call_data)
        #7， 30， 90天通话记录对应的夜间通话次数, 总通话次数，有效手机号数量列表
        night_times_list = []
        call_times_list = []
        call_valid_num_list = []
        continue_no_call_times_list = []
        #遍历7， 30， 90天通话记录
        for call_item in call_data_list:
            night_times_list.append(night_call_times(call_item[0]))
            call_times_list.append([len(call_item[0]), len(call_item[0][call_item[0]['dial_type'] == 'DIAL']),
                                   len(call_item[0][call_item[0]['dial_type'] == 'DIALED'])])
            call_valid_num_list.append(call_valid_num(call_item[0]))
            continue_no_call_times_list.append(continue_no_call_times(call_item, time_range_list))
        print('**********************************************************************************************************')
        print('\n近7天，30天， 90天的夜间通话次数：', night_times_list)
        print('\n近7天，30天， 90天的总的通话次数以及主叫和被叫的通话次数：', call_times_list)
        print('\n近7天，30天， 90天的有效手机号码、主叫、被叫号码的数量：', call_valid_num_list)
        print('\n近7天，30天， 90天的连续1，2， 3天没有通话的次数：', continue_no_call_times_list)

        break






